---
phase: 04-rich-text-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mix.exs
  - lib/cromulent_web/components/message_component.ex
autonomous: true
requirements:
  - RTXT-01
  - RTXT-02
  - RTXT-04

must_haves:
  truths:
    - "Messages containing **bold**, _italic_, `code`, lists, and > blockquotes render as styled HTML, not raw markdown syntax"
    - "Bare URLs in message bodies are automatically converted to clickable anchor tags"
    - "Messages containing image URLs (ending in .jpg .jpeg .png .gif .webp .svg) display inline embedded images"
    - "Broken/unreachable image URLs show a visible placeholder instead of a broken-image icon"
    - "Mention pills (@username) still render correctly alongside markdown and image segments"
    - "User-generated markdown cannot inject script tags or event handler attributes (XSS safe)"
  artifacts:
    - path: "mix.exs"
      provides: "MDEx dependency + Floki promoted from test-only to all envs"
      contains: "{:mdex, \"~> 0.11\"}"
    - path: "lib/cromulent_web/components/message_component.ex"
      provides: "Extended parse_segments/1 producing {:mention, token}, {:image, url}, {:markdown, text} tuples; render loop handling all three segment types with MDEx for markdown"
      exports: []
  key_links:
    - from: "lib/cromulent_web/components/message_component.ex parse_segments/1"
      to: "MDEx.to_html!/2"
      via: "render_markdown/1 private function called for each {:markdown, text} segment"
      pattern: "MDEx\\.to_html!"
    - from: "lib/cromulent_web/components/message_component.ex"
      to: "Phoenix.HTML.raw/1"
      via: "wrapped around MDEx output to emit safe HTML in HEEx template"
      pattern: "Phoenix\\.HTML\\.raw"
    - from: "parse_segments/1 image detection"
      to: "{:image, url} segment tuple"
      via: "image URL regex split before mention split — image URLs never reach MDEx"
      pattern: "\\{:image,"
---

<objective>
Add MDEx markdown rendering, URL auto-linking, and inline image embedding to the message component. This is the core rich text layer — all rendering happens server-side in Phoenix Components, consistent with the established project pattern.

Purpose: Users see formatted messages (bold, italic, code blocks, etc.) and inline images without any client-side JS rendering.
Output: Updated mix.exs with MDEx + Floki deps; updated message_component.ex with three-segment parse pipeline and corresponding render logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-rich-text-rendering/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From lib/cromulent_web/components/message_component.ex (lines 144-154) — current parse_segments/1:
```elixir
defp parse_segments(body) do
  ~r/@([\w]+)/
  |> Regex.split(body, include_captures: true, trim: false)
  |> Enum.map(fn part ->
    case Regex.run(~r/^@([\w]+)$/, part, capture: :all_but_first) do
      [token] -> {:mention, token}
      nil -> part
    end
  end)
  |> Enum.reject(&(&1 == ""))
end
```

Current render loop (lines 87-98) handles {:mention, token} and plain text strings.
After this plan, parse_segments/1 must produce three tuple types:
  {:mention, token}  — existing, unchanged
  {:image, url}      — NEW: bare image URL extracted before markdown processing
  {:markdown, text}  — NEW: replaces plain strings; rendered via MDEx

From mix.exs (line 43): `{:floki, ">= 0.30.0", only: :test}` — must remove `only: :test`.
From mix.exs (line 55): `{:finch, "~> 0.13"}` — already present, no change needed.
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add MDEx dependency and promote Floki to all environments</name>
  <files>mix.exs</files>
  <behavior>
    - After `mix deps.get`, `MDEx` module is available in all Mix environments (dev, test, prod)
    - After `mix deps.get`, `Floki` module is available in all Mix environments (not test-only)
    - `mix compile` succeeds with no warnings about missing modules
  </behavior>
  <action>
In mix.exs, inside the `deps/0` function:

1. Add MDEx after the existing Floki line:
   `{:mdex, "~> 0.11"},`

2. Change the existing Floki entry from:
   `{:floki, ">= 0.30.0", only: :test}`
   to:
   `{:floki, ">= 0.30.0"},`
   (Remove the `only: :test` restriction — Floki is needed at runtime for link previews in Plan 02.)

Then run:
```bash
mix deps.get
```

Do NOT add `html_sanitize_ex` — MDEx includes ammonia-based sanitization built-in via `features: [sanitize: true]`.
  </action>
  <verify>
    <automated>mix deps.get && mix compile 2>&1 | tail -5</automated>
  </verify>
  <done>mix.exs contains `{:mdex, "~> 0.11"}` and `{:floki, ">= 0.30.0"}` (no `only: :test`). `mix compile` exits 0 with no errors.</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Extend parse_segments/1 pipeline and render markdown, images, and mentions</name>
  <files>lib/cromulent_web/components/message_component.ex</files>
  <behavior>
    - Test: parse_segments("hello") returns [{:markdown, "hello"}]
    - Test: parse_segments("@alice hello") returns [{:mention, "alice"}, {:markdown, " hello"}]
    - Test: parse_segments("https://example.com/photo.png") returns [{:image, "https://example.com/photo.png"}]
    - Test: parse_segments("see https://example.com/photo.jpg and @alice") returns [{:image, "https://example.com/photo.jpg"}, {:markdown, " and "}, {:mention, "alice"}]
    - Test: parse_segments("**bold**") returns [{:markdown, "**bold**"}]
    - Test: render_markdown("**bold**") returns HTML string containing "&lt;strong&gt;bold&lt;/strong&gt;" (or the raw "<strong>bold</strong>")
    - Test: render_markdown("`code`") returns HTML containing "<code>code</code>" (MDEx sanitize must allow code tags — if not, use explicit allow_tags option)
    - Test: render_markdown("Visit https://example.com") returns HTML with an `<a href="https://example.com">` anchor tag (autolink)
    - Test: render_markdown("<script>alert(1)</script>") does NOT contain "<script" in output (XSS sanitized)
  </behavior>
  <action>
Rewrite `lib/cromulent_web/components/message_component.ex` to implement the three-segment pipeline.

**Step 1: Rewrite parse_segments/1**

Replace the current `parse_segments/1` (lines 144-154) with:

```elixir
@image_url_regex ~r/https?:\/\/\S+\.(?:jpg|jpeg|png|gif|webp|svg)(?:\?\S*)?/i

defp parse_segments(body) do
  # Phase 1: Split on image URLs — extract {:image, url} segments
  body
  |> split_images()
  |> Enum.flat_map(fn
    {:image, url} ->
      [{:image, url}]

    text when is_binary(text) ->
      # Phase 2: Within non-image text, split on @mentions
      ~r/@([\w]+)/
      |> Regex.split(text, include_captures: true, trim: false)
      |> Enum.map(fn part ->
        case Regex.run(~r/^@([\w]+)$/, part, capture: :all_but_first) do
          [token] -> {:mention, token}
          nil -> {:markdown, part}
        end
      end)
      |> Enum.reject(&match?({:markdown, ""}, &1))
  end)
  |> Enum.reject(fn
    {:markdown, ""} -> true
    _ -> false
  end)
end

defp split_images(body) do
  parts = Regex.split(@image_url_regex, body, include_captures: true, trim: false)
  Enum.map(parts, fn part ->
    if Regex.match?(@image_url_regex, part) do
      {:image, part}
    else
      part
    end
  end)
  |> Enum.reject(&(&1 == ""))
end
```

**Step 2: Add render_markdown/1 private function**

```elixir
defp render_markdown(text) do
  html =
    MDEx.to_html!(text,
      extension: [autolink: true, strikethrough: false, table: false],
      parse: [relaxed_autolinks: true],
      features: [sanitize: true]
    )

  Phoenix.HTML.raw(html)
end
```

IMPORTANT: If tests show that `features: [sanitize: true]` strips `<code>` or `<pre>` tags (Pitfall 2 from research), use explicit allow_tags:
```elixir
features: [sanitize: [allow_tags: ["p", "br", "strong", "em", "code", "pre", "ul", "ol", "li", "blockquote", "a"]]]
```
Test this with `` `inline code` `` and a fenced code block BEFORE shipping.

**Step 3: Update the render loop in the HEEx template**

Replace the current segment render loop (inside `<p class="break-words">`, lines 87-98) with:

```heex
<p class="break-words">
  <%= for segment <- @segments do %>
    <%= case segment do %>
      <% {:mention, token} -> %>
        <.mention_pill
          token={token}
          current_user={@current_user}
          mentions={@message.mentions}
        />
      <% {:image, url} -> %>
        <div class="mt-1">
          <img
            src={url}
            class="max-w-[400px] max-h-[300px] object-contain rounded"
            onerror="this.style.display='none'; this.nextElementSibling.removeAttribute('style')"
          />
          <div style="display:none" class="flex w-48 h-24 rounded bg-gray-600 items-center justify-center text-xs text-gray-400 mt-1">
            Image unavailable
          </div>
        </div>
      <% {:markdown, text} -> %>
        <%= render_markdown(text) %>
    <% end %>
  <% end %>
</p>
```

The `render_markdown/1` function returns a `Phoenix.HTML.safe` value from `Phoenix.HTML.raw/1`, which HEEx renders as raw HTML without double-escaping.

**Step 4: Add `require MDEx` or alias if needed**

MDEx is a module-based library. No alias is needed — call `MDEx.to_html!/2` directly.

**Pitfall to avoid (from research):**
Image URLs extracted as `{:image, url}` segments must NOT also be passed to MDEx. The split ensures image URLs become image segments before the markdown text reaches `render_markdown/1`. If a URL string reaches MDEx with `autolink: true`, it would render as a duplicate `<a>` tag — the image segment approach prevents this.
  </action>
  <verify>
    <automated>mix test --only unit 2>&1 || mix test test/cromulent_web/ 2>&1 | tail -20</automated>
  </verify>
  <done>
- parse_segments/1 produces {:mention, token}, {:image, url}, {:markdown, text} tuples correctly
- render_markdown/1 converts **bold** → &lt;strong&gt;, `code` → &lt;code&gt;, and bare URLs → &lt;a href&gt; anchors
- render_markdown/1 strips &lt;script&gt; tags (XSS safe)
- Image segments render as constrained &lt;img&gt; tags with broken-image fallback
- mix compile exits 0 with no errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `mix compile` — exits 0, no errors
2. `mix test` — all existing tests pass (no regressions)
3. Manual check: Start `mix phx.server`, send a message with `**bold** and _italic_ text`, confirm it renders as styled HTML in the browser (not raw asterisks)
4. Manual check: Send a message containing `https://example.com/photo.png`, confirm an image appears inline
5. Manual check: Send a message with `@username **hello**`, confirm mention pill AND bold text both render
</verification>

<success_criteria>
- mix.exs contains {:mdex, "~> 0.11"} and {:floki, ">= 0.30.0"} (all envs)
- parse_segments/1 in message_component.ex produces three segment types: {:mention, token}, {:image, url}, {:markdown, text}
- Markdown text segments render as sanitized HTML via MDEx (RTXT-01 + RTXT-02)
- Image URL segments render as constrained inline &lt;img&gt; tags with broken-image fallback (RTXT-04)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-rich-text-rendering/04-01-SUMMARY.md` summarizing:
- MDEx version pinned (e.g. 0.11.x resolved)
- Whether explicit allow_tags was needed for sanitize (document which tags)
- Final parse_segments/1 regex patterns used
- Any deviations from the plan and why
</output>
