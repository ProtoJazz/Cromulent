---
phase: 04-rich-text-rendering
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - mix.exs
  - lib/cromulent/messages/link_preview.ex
  - lib/cromulent/chat/room_server.ex
  - lib/cromulent_web/live/channel_live.ex
  - lib/cromulent_web/components/message_component.ex
autonomous: true
requirements:
  - RTXT-03

must_haves:
  truths:
    - "After a message containing a URL is sent, a preview card appears beneath the message showing the page title and description (within ~5s)"
    - "If OG metadata fetch fails (network error, timeout, non-HTML response), no preview card appears and the message renders normally"
    - "Link previews are skipped when LINK_PREVIEWS=disabled env var is set"
    - "The preview fetch does not block or freeze the send_message event — chat responds immediately"
    - "Preview cards with an og:image only display that image if the URL uses https:// scheme (XSS prevention)"
    - "Only the first URL in a message produces a preview card (no flooding)"
  artifacts:
    - path: "lib/cromulent/messages/link_preview.ex"
      provides: "LinkPreview.fetch/1 using Finch + Floki; returns {:ok, preview_map} or {:error, :fetch_failed}; validates og:image scheme"
      exports: ["fetch/1"]
    - path: "lib/cromulent/chat/room_server.ex"
      provides: "handle_cast :broadcast_message fires Task.start after message broadcast if non-image URL exists in body"
      contains: "Task.start"
    - path: "lib/cromulent_web/live/channel_live.ex"
      provides: "handle_info {:link_preview, msg_id, preview} patches messages list to attach preview map to matching message"
      contains: "link_preview"
    - path: "lib/cromulent_web/components/message_component.ex"
      provides: "link_preview/1 private component renders Discord-style preview card when message.link_preview is set"
      contains: "link_preview"
  key_links:
    - from: "lib/cromulent/chat/room_server.ex handle_cast :broadcast_message"
      to: "Cromulent.Messages.LinkPreview.fetch/1"
      via: "Task.start fire-and-forget after PubSub broadcast of new message"
      pattern: "Task\\.start"
    - from: "Cromulent.Messages.LinkPreview.fetch/1"
      to: "PubSub.broadcast {:link_preview, message_id, preview}"
      via: "Task process broadcasts result to text channel topic"
      pattern: "\\{:link_preview,"
    - from: "lib/cromulent_web/live/channel_live.ex handle_info :link_preview"
      to: "socket.assigns.messages"
      via: "Enum.map patches matching message map with :link_preview key"
      pattern: "link_preview"
    - from: "lib/cromulent_web/components/message_component.ex"
      to: "message.link_preview"
      via: "link_preview/1 component renders card when assigns.message[:link_preview] is non-nil"
      pattern: "link_preview"
---

<objective>
Implement ephemeral link preview cards (Open Graph). After a message containing a URL is sent, RoomServer asynchronously fetches OG metadata and broadcasts a patch; ChannelLive updates the message in-place; the message component renders a preview card.

Purpose: URLs in messages show rich preview cards (title, description, thumbnail) like Discord/Slack. Fetch is fire-and-forget — no database storage, no UI blocking.
Output: New LinkPreview module; updated RoomServer, ChannelLive, and MessageComponent; preview cards visible in the chat feed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-rich-text-rendering/04-RESEARCH.md
@.planning/phases/04-rich-text-rendering/04-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From lib/cromulent/chat/room_server.ex — handle_cast :broadcast_message (lines 53-84):
The cast receives `{message, notified_user_ids}`. After the existing PubSub broadcasts, add
the async OG fetch block. `topic/1` is a private helper returning `"text:#{channel_id}"`.

Key existing pattern in room_server.ex:
```elixir
def handle_cast({:broadcast_message, message, notified_user_ids}, state) do
  PubSub.broadcast(Cromulent.PubSub, topic(state.channel_id), {:new_message, message})
  # ... existing notification broadcasts ...
  {:noreply, state}
end
```

From lib/cromulent_web/live/channel_live.ex — existing handle_info patterns:
```elixir
def handle_info({:new_message, message}, socket) do ... end
def handle_info({:message_deleted, message_id}, socket) do ... end
# Catch-all at line 360:
def handle_info(_, socket), do: {:noreply, socket}
```
Add new handle_info BEFORE the catch-all.

From lib/cromulent_web/components/message_component.ex — message/1 assigns (after Plan 01):
- assigns.message.body :: String.t()
- assigns.message.id :: integer() | binary()
- assigns.message[:link_preview] :: nil | %{title: ..., description: ..., image_url: ..., url: ...}
  (link_preview key may be absent from messages loaded before preview arrives)

Preview struct shape (from research):
```elixir
%{
  title: "Page Title",        # og:title || <title> text
  description: "...",          # og:description || meta description (may be nil)
  image_url: "https://...",    # og:image — ONLY if https:// scheme (nil otherwise)
  url: "https://..."           # og:url || original URL
}
```

Finch instance name: `Cromulent.Finch` (already started in Application).
Floki is now available in all envs (promoted in Plan 01).
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create LinkPreview module and wire async fetch into RoomServer</name>
  <files>
    lib/cromulent/messages/link_preview.ex,
    lib/cromulent/chat/room_server.ex
  </files>
  <behavior>
    - Test: LinkPreview.fetch/1 with a URL that returns an HTML page with og:title meta tag returns {:ok, %{title: "...", ...}}
    - Test: LinkPreview.fetch/1 with a non-200 response returns {:error, :fetch_failed}
    - Test: LinkPreview.fetch/1 with a URL whose og:image is "javascript:alert(1)" returns {:ok, preview} where preview.image_url is nil (scheme validation strips non-https)
    - Test: LinkPreview.fetch/1 with an og:image using "https://" returns {:ok, preview} where preview.image_url starts with "https://"
    - Test: extract_first_link/1 with "check out https://github.com/foo/bar for details" returns "https://github.com/foo/bar"
    - Test: extract_first_link/1 with "https://example.com/photo.png is cool" returns nil (image URLs are excluded — they are already embedded inline)
    - Test: extract_first_link/1 with "no urls here" returns nil
  </behavior>
  <action>
**Create lib/cromulent/messages/link_preview.ex:**

```elixir
defmodule Cromulent.Messages.LinkPreview do
  @moduledoc """
  Fetches Open Graph metadata for a URL using Finch and Floki.
  Returns an ephemeral preview struct — no database storage.
  """

  @image_extensions ~w(.jpg .jpeg .png .gif .webp .svg)
  @link_regex ~r/https?:\/\/[^\s]+/i
  @image_url_regex ~r/https?:\/\/\S+\.(?:jpg|jpeg|png|gif|webp|svg)(?:\?\S*)?/i
  @timeout 5_000

  @doc """
  Fetches OG metadata for the given URL.
  Returns {:ok, preview_map} or {:error, :fetch_failed}.
  """
  def fetch(url) when is_binary(url) do
    with {:ok, %{body: body, status: status}} when status in 200..299 <-
           Finch.build(:get, url, [{"user-agent", "Cromulent/1.0 LinkPreview"}])
           |> Finch.request(Cromulent.Finch, receive_timeout: @timeout),
         {:ok, document} <- Floki.parse_document(body) do
      {:ok, extract_og(document, url)}
    else
      _ -> {:error, :fetch_failed}
    end
  end

  @doc """
  Extracts the first non-image URL from a message body.
  Returns nil if no eligible URL found.
  Image URLs are excluded because they are already embedded as inline images.
  """
  def extract_first_link(body) when is_binary(body) do
    @link_regex
    |> Regex.scan(body)
    |> List.flatten()
    |> Enum.find(fn url ->
      uri = URI.parse(url)
      extension = uri.path && Path.extname(uri.path) |> String.downcase()
      extension not in @image_extensions
    end)
  end

  # ── Private ──────────────────────────────────────────────────

  defp extract_og(document, fallback_url) do
    meta = fn property ->
      document
      |> Floki.find("meta[property='#{property}'], meta[name='#{property}']")
      |> Floki.attribute("content")
      |> List.first()
    end

    title =
      meta.("og:title") ||
        (document |> Floki.find("title") |> Floki.text() |> blank_to_nil())

    description =
      meta.("og:description") || meta.("description")

    raw_image = meta.("og:image")
    # Security: only allow https:// image URLs in preview cards to prevent XSS via javascript: URIs
    image_url =
      if raw_image && String.starts_with?(raw_image, "https://") do
        raw_image
      else
        nil
      end

    %{
      title: title,
      description: description,
      image_url: image_url,
      url: meta.("og:url") || fallback_url
    }
  end

  defp blank_to_nil(""), do: nil
  defp blank_to_nil(str), do: str
end
```

**Update lib/cromulent/chat/room_server.ex — handle_cast :broadcast_message:**

After the existing PubSub broadcasts (after the `for user_id <- notified_user_ids do ... end` desktop notification loop, before `{:noreply, state}`), add the async OG fetch block:

```elixir
# Async link preview fetch — fire-and-forget, does not block the cast
if System.get_env("LINK_PREVIEWS") != "disabled" do
  channel_id = state.channel_id

  if url = Cromulent.Messages.LinkPreview.extract_first_link(message.body) do
    Task.start(fn ->
      case Cromulent.Messages.LinkPreview.fetch(url) do
        {:ok, preview} ->
          PubSub.broadcast(
            Cromulent.PubSub,
            "text:#{channel_id}",
            {:link_preview, message.id, preview}
          )

        _ ->
          :noop
      end
    end)
  end
end
```

Place this block inside `handle_cast({:broadcast_message, message, notified_user_ids}, state)`, after the existing notification broadcasts and before `{:noreply, state}`.

Do NOT use `Task.async` here — there is no caller waiting to await the result. `Task.start` is the correct choice for fire-and-forget work from a GenServer.
  </action>
  <verify>
    <automated>mix test test/cromulent/messages/ 2>&1 || mix test 2>&1 | tail -20</automated>
  </verify>
  <done>
- lib/cromulent/messages/link_preview.ex exists and compiles
- LinkPreview.fetch/1 returns {:ok, preview_map} for valid HTML pages, {:error, :fetch_failed} for failures
- og:image with non-https scheme is stripped to nil in preview_map
- extract_first_link/1 returns nil for image URL bodies
- RoomServer handle_cast :broadcast_message fires Task.start for non-image URLs
- mix compile exits 0 with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire handle_info in ChannelLive and render preview card in MessageComponent</name>
  <files>
    lib/cromulent_web/live/channel_live.ex,
    lib/cromulent_web/components/message_component.ex
  </files>
  <action>
**Update lib/cromulent_web/live/channel_live.ex:**

Add a new `handle_info` clause BEFORE the existing catch-all `def handle_info(_, socket)` (line 360):

```elixir
def handle_info({:link_preview, msg_id, preview}, socket) do
  messages =
    Enum.map(socket.assigns.messages, fn
      %{id: ^msg_id} = m -> Map.put(m, :link_preview, preview)
      m -> m
    end)

  {:noreply, assign(socket, :messages, messages)}
end
```

This patches the in-memory messages list when a preview arrives. No database write occurs. If the user has already navigated away, the message won't be in the list and the map passes through unchanged.

**Update lib/cromulent_web/components/message_component.ex:**

1. Add the `link_preview/1` private component function:

```elixir
defp link_preview(assigns) do
  ~H"""
  <div class="mt-2 max-w-sm rounded border border-gray-600 bg-gray-800 overflow-hidden">
    <%= if @preview[:image_url] do %>
      <img
        src={@preview.image_url}
        class="w-full max-h-40 object-cover"
        onerror="this.style.display='none'"
      />
    <% end %>
    <div class="p-2">
      <%= if @preview[:title] do %>
        <p class="text-sm font-semibold text-white truncate">{@preview.title}</p>
      <% end %>
      <%= if @preview[:description] do %>
        <p class="text-xs text-gray-400 mt-0.5 line-clamp-2">{@preview.description}</p>
      <% end %>
      <a href={@preview.url} target="_blank" rel="noopener noreferrer"
         class="text-xs text-indigo-400 hover:underline mt-1 block truncate">
        {@preview.url}
      </a>
    </div>
  </div>
  """
end
```

2. In the `message/1` component's outer content div (the bubble div containing `<p class="break-words">`), after the closing `</p>` tag, add:

```heex
<%= if preview = @message[:link_preview] do %>
  <.link_preview preview={preview} />
<% end %>
```

The `@message[:link_preview]` access pattern safely returns nil when the key is absent (messages loaded before a preview arrives don't have this key).

3. The `link_preview` component needs an `attr` declaration. Add before the `defp link_preview(assigns)`:
```elixir
attr :preview, :map, required: true
```

**Placement note:** The link preview card appears OUTSIDE the `<p class="break-words">` tag, still inside the message bubble div, so it extends below the text naturally.
  </action>
  <verify>
    <automated>mix compile 2>&1 | tail -10 && mix test 2>&1 | tail -20</automated>
  </verify>
  <done>
- ChannelLive has handle_info clause for {:link_preview, msg_id, preview} before the catch-all
- MessageComponent has link_preview/1 private component with preview card HTML
- @message[:link_preview] nil-safe access renders nothing when key absent
- mix compile exits 0 with no errors
- All existing tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `mix compile` — exits 0
2. `mix test` — all tests pass
3. Manual smoke test: Start server with `mix phx.server`, send a message containing a URL to a page with OG tags (e.g. "https://github.com"). Within ~5 seconds a preview card should appear below the message.
4. Confirm preview fetch failure is silent: Send a message with a URL to a non-existent page. No error visible, message renders normally without a preview card.
5. Confirm LINK_PREVIEWS guard: Set `LINK_PREVIEWS=disabled` env and send a URL-containing message. No preview card appears.
</verification>

<success_criteria>
- lib/cromulent/messages/link_preview.ex exists with fetch/1 and extract_first_link/1
- RoomServer broadcasts {:link_preview, message_id, preview} asynchronously after :broadcast_message (RTXT-03)
- ChannelLive patches messages list on {:link_preview, ...} receipt
- MessageComponent renders preview card with title, description, optional image, and URL
- og:image with non-https scheme is stripped (XSS prevention)
- All four RTXT requirements (RTXT-01, RTXT-02, RTXT-03, RTXT-04) are implemented across Plans 01 and 02
</success_criteria>

<output>
After completion, create `.planning/phases/04-rich-text-rendering/04-02-SUMMARY.md` summarizing:
- OG fetch working or any Finch/Floki integration issues
- Whether LINK_PREVIEWS env guard was tested
- Any deviations from the plan and why
- Confirmation that all four RTXT requirements are met
</output>
