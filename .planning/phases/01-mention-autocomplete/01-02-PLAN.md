---
phase: 01-mention-autocomplete
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - assets/js/app.js
  - assets/js/hooks/mention_autocomplete.js
autonomous: false
requirements:
  - MENT-01
  - MENT-02

must_haves:
  truths:
    - "User types @ in message input and sees autocomplete dropdown appear"
    - "User navigates suggestions with arrow keys and selected item is highlighted"
    - "User presses Enter to select a mention and it inserts into the input"
    - "User presses Escape to close autocomplete without selecting"
    - "Cursor position is correct after mention insertion (not jumping to end)"
    - "Form does not submit when pressing Enter to select a mention"
    - "Autocomplete closes when user deletes the @ trigger character"
  artifacts:
    - path: "assets/js/hooks/mention_autocomplete.js"
      provides: "MentionAutocomplete LiveView Hook with cursor detection and keyboard nav"
      contains: "MentionAutocomplete"
      min_lines: 50
    - path: "assets/js/app.js"
      provides: "Hook registration in LiveSocket"
      contains: "MentionAutocomplete"
  key_links:
    - from: "assets/js/hooks/mention_autocomplete.js"
      to: "lib/cromulent_web/live/channel_live.ex"
      via: "pushEvent for autocomplete_open, autocomplete_close, autocomplete_navigate, autocomplete_select"
      pattern: "pushEvent.*autocomplete"
    - from: "assets/js/hooks/mention_autocomplete.js"
      to: "lib/cromulent_web/live/channel_live.ex"
      via: "handleEvent for mention_selected"
      pattern: "handleEvent.*mention_selected"
    - from: "assets/js/app.js"
      to: "assets/js/hooks/mention_autocomplete.js"
      via: "import and Hooks registration"
      pattern: "import.*mention_autocomplete"
---

<objective>
Create the JavaScript Hook that detects @ triggers from cursor position, handles keyboard navigation, and inserts selected mentions into the message input.

Purpose: This is the client-side half of the autocomplete — it makes the dropdown interactive by detecting when the user types @, sending filter queries to LiveView, intercepting keyboard events (arrows, Enter, Escape), and inserting the selected mention text at the correct cursor position.

Output: A working MentionAutocomplete Hook wired into the LiveSocket, completing the full autocomplete interaction flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mention-autocomplete/01-CONTEXT.md
@.planning/phases/01-mention-autocomplete/01-RESEARCH.md
@.planning/phases/01-mention-autocomplete/01-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 — the LiveView events the Hook must communicate with -->

ChannelLive event handlers (server-side):
- `"autocomplete_open"` expects `%{"query" => string}` — opens dropdown with filtered results
- `"autocomplete_close"` expects `%{}` — closes dropdown
- `"autocomplete_navigate"` expects `%{"direction" => "up" | "down"}` — moves selection
- `"autocomplete_select"` expects `%{"index" => integer}` — selects item at index

ChannelLive push_event (server → client):
- `"mention_selected"` sends `%{text: "@username "}` — the text to insert at cursor

Hook attachment point in channel_live.ex template:
- Element with `id="mention-hook"` and `phx-hook="MentionAutocomplete"`
- `data-selected-index={@autocomplete_index}` attribute on the hook element
- Input is `<input name="body">` inside a `<form phx-submit="send_message">`

From assets/js/app.js:
```javascript
const Hooks = {
  VoiceRoom: { ... },
  ChatScroll: { ... }
}
// MentionAutocomplete needs to be added here
let liveSocket = new LiveSocket("/live", Socket, { hooks: Hooks, ... })
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MentionAutocomplete JS Hook with cursor detection and keyboard nav</name>
  <files>assets/js/hooks/mention_autocomplete.js</files>
  <action>
Create directory `assets/js/hooks/` if it doesn't exist.

Create `mention_autocomplete.js` exporting a MentionAutocomplete Hook object with these lifecycle methods:

**`mounted()`:**
1. Find the input element: `this.input = this.el.querySelector('input[name="body"]')` (or `textarea` if changed)
2. Initialize state: `this.autocompleteOpen = false`, `this.mentionStartPos = null`
3. Add `input` event listener on the input element → calls `this.handleInput(e)`
4. Add `keydown` event listener on the input element → calls `this.handleKeydown(e)`
5. Register `this.handleEvent("mention_selected", ({text}) => this.insertMention(text))` — server pushes selected mention text back

**`handleInput(e)`:**
1. Get cursor position: `const cursorPos = this.input.selectionStart`
2. Get text before cursor: `const textBefore = this.input.value.slice(0, cursorPos)`
3. Match @ trigger: `const match = textBefore.match(/@(\w*)$/)`
4. If match found:
   - Set `this.mentionStartPos = cursorPos - match[0].length` (position of the @ character)
   - Set `this.autocompleteOpen = true`
   - `this.pushEvent("autocomplete_open", { query: match[1] })` — match[1] is text after @
5. If no match AND autocomplete is open:
   - Set `this.autocompleteOpen = false`
   - `this.pushEvent("autocomplete_close", {})`

**`handleKeydown(e)`:**
1. If `!this.autocompleteOpen` → return (don't intercept normal typing)
2. Switch on `e.key`:
   - `'ArrowDown'`: `e.preventDefault()` + `this.pushEvent("autocomplete_navigate", { direction: "down" })`
   - `'ArrowUp'`: `e.preventDefault()` + `this.pushEvent("autocomplete_navigate", { direction: "up" })`
   - `'Enter'`: `e.preventDefault()` (CRITICAL: prevents form submit!) + `e.stopPropagation()` + read `this.el.dataset.selectedIndex` + `this.pushEvent("autocomplete_select", { index: parseInt(selectedIndex) })`
   - `'Escape'`: `e.preventDefault()` + `this.autocompleteOpen = false` + `this.pushEvent("autocomplete_close", {})`
   - `'Tab'`: Same as Enter — select current item (Discord/Slack behavior)

**`insertMention(text)`:**
1. Get current value: `const value = this.input.value`
2. Get text before the @ trigger: `const before = value.slice(0, this.mentionStartPos)`
3. Get text after current cursor: `const after = value.slice(this.input.selectionStart)`
4. Build new value: `const newValue = before + text + after`
5. Set input value: `this.input.value = newValue`
6. Calculate new cursor position: `const newPos = this.mentionStartPos + text.length`
7. Set cursor: `this.input.selectionStart = newPos; this.input.selectionEnd = newPos`
8. Reset state: `this.autocompleteOpen = false; this.mentionStartPos = null`
9. Focus input: `this.input.focus()` — ensure input retains focus after mention insertion
10. Dispatch an `input` event on the input element so LiveView picks up the value change: `this.input.dispatchEvent(new Event('input', { bubbles: true }))`

**`updated()`:**
- Sync `this.autocompleteOpen` with the DOM state (check if dropdown is visible via `this.el.querySelector('[role="listbox"]')`)
- Update ARIA `aria-activedescendant` on input: `this.input.setAttribute('aria-activedescendant', 'mention-option-' + this.el.dataset.selectedIndex)`

**`destroyed()`:**
- Clean up event listeners if needed (though since they're on child elements, this is optional)

Export as: `export default MentionAutocomplete` (object, not class)

Key pitfalls to handle (from RESEARCH.md):
- Enter MUST preventDefault when autocomplete is open (Pitfall 1)
- Cursor position MUST be set after mention insertion (Pitfall 2)
- Autocomplete should close when @ is deleted (handled by handleInput no-match path)
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && ls assets/js/hooks/mention_autocomplete.js && node -c assets/js/hooks/mention_autocomplete.js 2>&1 || echo "Syntax check (may fail on ESM import but file should exist)"</automated>
  </verify>
  <done>
- Hook detects @ character at cursor position and sends query to LiveView
- Arrow keys navigate selection without moving cursor in input
- Enter selects mention without submitting form
- Escape closes autocomplete
- Mention text inserted at correct cursor position with cursor placed after it
- ARIA attributes updated on each render cycle
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Hook in app.js and wire end-to-end</name>
  <files>assets/js/app.js</files>
  <action>
Import the MentionAutocomplete hook at the top of app.js (near the other imports):
```javascript
import MentionAutocomplete from "./hooks/mention_autocomplete"
```

Add `MentionAutocomplete` to the existing Hooks object:
```javascript
const Hooks = {
  VoiceRoom: { ... },  // existing
  ChatScroll: { ... },  // existing
  MentionAutocomplete   // new — ES6 shorthand since import name matches
}
```

Verify the Hook name matches exactly what's in the `phx-hook="MentionAutocomplete"` attribute in channel_live.ex template (from Plan 01).
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix assets.build 2>&1 | tail -10 || (cd assets && npx esbuild js/app.js --bundle --outdir=../priv/static/assets 2>&1 | tail -10)</automated>
  </verify>
  <done>
- MentionAutocomplete Hook is imported and registered in Hooks object
- Asset build succeeds with no errors
- The full autocomplete flow works: type @ → dropdown appears → arrow keys navigate → Enter/Tab selects → mention inserts at cursor
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete autocomplete flow in browser</name>
  <files>n/a</files>
  <action>
Human verifies the complete @mention autocomplete system.

What was built: Complete @mention autocomplete — type @ in message input to see a filterable dropdown of channel members, broadcast targets (@everyone, @here), and groups. Navigate with arrow keys, select with Enter/Tab, dismiss with Escape.

How to verify:
1. Start the dev server: `mix phx.server` (ensure docker compose is running for PostgreSQL)
2. Open http://localhost:4000 and log in
3. Navigate to any text channel
4. In the message input, type `@` — verify dropdown appears above input
5. Continue typing a username — verify results filter in real-time
6. Press ArrowDown/ArrowUp — verify selection highlight moves
7. Press Enter — verify mention inserts into input (e.g., "@username ") and dropdown closes
8. Verify cursor is positioned after the inserted mention, not at end of input
9. Type `@every` — verify @everyone appears in results with indigo styling
10. Type `@here` — verify @here appears
11. Press Escape — verify dropdown closes without inserting
12. Submit a message with a mention — verify it sends correctly (existing mention pill rendering should work)
13. Verify that pressing Enter when autocomplete is closed still submits the form normally

Resume signal: Type "approved" or describe any issues with the autocomplete behavior.
  </action>
  <verify>Human visual and functional verification</verify>
  <done>User confirms autocomplete feels like Discord/Slack: responsive filtering, smooth keyboard nav, correct mention insertion</done>
</task>

</tasks>

<verification>
1. Asset build completes without errors
2. `mix compile --warnings-as-errors` passes
3. Full autocomplete flow works in browser: @ trigger → filter → navigate → select → insert
4. Form submission still works normally when autocomplete is not open
5. Mentions display correctly in sent messages (existing mention_pill rendering)
</verification>

<success_criteria>
- Typing @ in message input triggers autocomplete dropdown
- Keyboard navigation (up/down/enter/escape) works smoothly
- Selected mention inserts at correct cursor position
- Form does not submit when selecting a mention with Enter
- All three mention types (user, broadcast, group) appear with correct styling
- Human verification confirms the interaction feels like Discord/Slack
</success_criteria>

<output>
After completion, create `.planning/phases/01-mention-autocomplete/01-02-SUMMARY.md`
</output>
