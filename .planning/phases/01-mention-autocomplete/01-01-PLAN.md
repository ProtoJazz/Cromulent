---
phase: 01-mention-autocomplete
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cromulent_web/live/channel_live.ex
  - lib/cromulent_web/components/mention_autocomplete.ex
autonomous: true
requirements:
  - MENT-01
  - MENT-03
  - MENT-04

must_haves:
  truths:
    - "LiveView tracks autocomplete state (open/closed, query, results, selected index)"
    - "Filtering returns channel members matching the query with prefix/contains matching"
    - "Broadcast targets (@everyone, @here) appear in results when query is empty or matches"
    - "Groups appear in results alongside users with distinct visual treatment"
    - "Autocomplete dropdown renders above the message input with max 5 visible items"
    - "Each user row shows avatar initial + display name + dimmed @username"
  artifacts:
    - path: "lib/cromulent_web/live/channel_live.ex"
      provides: "Autocomplete event handlers and filtering logic"
      contains: "autocomplete_open"
    - path: "lib/cromulent_web/components/mention_autocomplete.ex"
      provides: "Autocomplete dropdown component with Flowbite styling"
      contains: "mention_autocomplete"
  key_links:
    - from: "lib/cromulent_web/live/channel_live.ex"
      to: "Cromulent.Channels.list_members/1"
      via: "filter_mention_targets function"
      pattern: "list_members"
    - from: "lib/cromulent_web/live/channel_live.ex"
      to: "Cromulent.Groups.list_groups/0"
      via: "filter_mention_targets function"
      pattern: "list_groups"
    - from: "lib/cromulent_web/live/channel_live.ex"
      to: "lib/cromulent_web/components/mention_autocomplete.ex"
      via: "component render in template"
      pattern: "mention_autocomplete"
---

<objective>
Add autocomplete backend state management to ChannelLive and create the dropdown UI component.

Purpose: Establish the server-side filtering logic and visual dropdown that displays channel members, groups, and broadcast targets when a user types @. This is the foundation that the JS Hook (Plan 02) will drive.

Output: ChannelLive handles autocomplete events and renders a Flowbite-styled dropdown component above the message input.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mention-autocomplete/01-CONTEXT.md
@.planning/phases/01-mention-autocomplete/01-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From lib/cromulent_web/live/channel_live.ex:
- `mount/3` assigns: `:channel`, `:messages`, `:typing_users`, `:can_write`, `:current_user`
- `handle_params/3` loads channel via `Cromulent.Channels.get_channel_by_slug(slug)` and members are available via `Cromulent.Channels.list_members(channel)`
- Template renders message input as a `<form phx-submit="send_message">` with `<input name="body">`
- Existing hooks: `ChatScroll`, `VoiceRoom` registered in `assets/js/app.js` Hooks object

From lib/cromulent/channels.ex:
```elixir
def list_members(channel) do
  from(u in Cromulent.Accounts.User,
    join: m in ChannelMembership,
    on: m.user_id == u.id,
    where: m.channel_id == ^channel.id,
    order_by: [asc: u.username]
  ) |> Repo.all()
end
```

From lib/cromulent/groups.ex:
```elixir
def list_groups do  # Returns [%Group{id, name, slug, color}]
def groups_by_slug do  # Returns %{slug => %Group{}}
```

From lib/cromulent/messages/mention_parser.ex:
```elixir
@broadcast_tokens %{"everyone" => :everyone, "all" => :everyone, "here" => :here}
```

From lib/cromulent_web/components/message_component.ex:
- Already renders mention pills with `mention_pill` component
- Uses `parse_segments/1` to split body into text and `{:mention, token}` tuples
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add autocomplete state and event handlers to ChannelLive</name>
  <files>lib/cromulent_web/live/channel_live.ex</files>
  <action>
Add autocomplete assigns to `mount/3`:
- `autocomplete_open: false` — whether dropdown is visible
- `autocomplete_query: ""` — current filter text after @
- `autocomplete_results: []` — filtered list of mention targets
- `autocomplete_index: 0` — currently highlighted item index

Add a private `filter_mention_targets/2` function that takes a channel and query string:
1. Fetch channel members via `Cromulent.Channels.list_members(channel)` — these are already loaded in handle_params but re-fetch is fine for correctness (channel members can change)
2. Fetch groups via `Cromulent.Groups.list_groups()`
3. Build broadcast targets list: `@everyone` and `@here` — include them when query is empty OR when "everyone"/"here" starts with the downcased query
4. Filter users: include if username starts with query (prefix) OR display_name (fallback to username) contains query. Sort by: exact match first, then prefix on username, then prefix on display_name, then contains
5. Filter groups: include if slug starts with query OR name contains query
6. Return combined list: broadcast targets first, then users, then groups. Each item is a map with `:type` key (`:broadcast`, `:user`, `:group`) and relevant data

Add these `handle_event` clauses (place them BEFORE the catch-all or other handlers):

- `"autocomplete_open"` with `%{"query" => query}` — call `filter_mention_targets`, assign results + set `autocomplete_open: true`, `autocomplete_index: 0`
- `"autocomplete_close"` — assign `autocomplete_open: false`, clear results
- `"autocomplete_navigate"` with `%{"direction" => dir}` — increment/decrement `autocomplete_index`, clamp between 0 and `length(results) - 1`
- `"autocomplete_select"` with `%{"index" => index}` — get selected item from results, format as mention string (e.g., "@username ", "@everyone ", "@groupslug "), push_event "mention_selected" with `%{text: mention_text}`, then close autocomplete

Update the `render/1` template:
- Wrap the message input form area in a container with `position: relative` (add `class="relative"` to the flex-shrink-0 border-t div)
- Add the `phx-hook="MentionAutocomplete"` attribute to the form element (or a wrapper div around the input) — this is where the JS Hook will attach
- Add `data-selected-index={@autocomplete_index}` to the hook element so JS can read it
- Render the `<.mention_autocomplete>` component above the input, passing: `open={@autocomplete_open}`, `results={@autocomplete_results}`, `selected_index={@autocomplete_index}`
- Add `id="mention-hook"` to the hook element for stable DOM identity

Note: The input's existing `phx-keydown="typing_start"` will coexist with the JS Hook keyboard handling. The Hook will intercept arrow/enter/escape when autocomplete is open and prevent them from reaching the form.
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile --warnings-as-errors 2>&1 | tail -20</automated>
  </verify>
  <done>
- ChannelLive has autocomplete assigns in mount
- filter_mention_targets/2 returns broadcast, user, and group results filtered by query
- Event handlers for open/close/navigate/select work correctly
- Template renders mention_autocomplete component and has MentionAutocomplete hook attachment point
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Flowbite-styled autocomplete dropdown component</name>
  <files>lib/cromulent_web/components/mention_autocomplete.ex</files>
  <action>
Create a new Phoenix function component module `CromulentWeb.Components.MentionAutocomplete` with `use Phoenix.Component`.

Define `mention_autocomplete/1` as a public function component with these attrs:
- `open` (`:boolean`, required) — controls visibility
- `results` (`:list`, required) — list of mention target maps
- `selected_index` (`:integer`, required) — currently highlighted index

Template structure (per user decision: popup ABOVE input, max 5 visible, Flowbite styling):
```heex
<div :if={@open}
     class="absolute bottom-full left-0 mb-1 w-72 bg-gray-800 border border-gray-600 rounded-lg shadow-lg z-50"
     role="listbox"
     id="mention-listbox"
     aria-label="Mention suggestions">
  <ul class="max-h-[220px] overflow-y-auto py-1">
    <!-- 220px ~= 5 items at ~44px each, per user decision of max 5 visible -->
    <li :for={{item, idx} <- Enum.with_index(@results)}
        role="option"
        id={"mention-option-#{idx}"}
        aria-selected={idx == @selected_index |> to_string()}
        phx-click="autocomplete_select"
        phx-value-index={idx}
        class={[
          "px-3 py-2 flex items-center gap-3 cursor-pointer text-sm",
          if(idx == @selected_index, do: "bg-gray-700 text-white", else: "text-gray-300 hover:bg-gray-700/50")
        ]}>
      <!-- Render based on type -->
    </li>
  </ul>
</div>
```

For each item type, render per user decision (avatar + display name + dimmed @username):

**`:user` type:**
- Avatar circle (use first letter of username, same pattern as message_component.ex: `h-7 w-7 rounded-full bg-indigo-600 flex items-center justify-center text-white text-xs font-medium`)
- Display name in white (use `item.user.email` split or `item.user.username` — check what display_name field exists on User schema, fall back to username)
- Dimmed `@username` in `text-gray-400 text-xs`

**`:broadcast` type:**
- A broadcast icon or @ symbol in indigo circle
- Label text in `text-indigo-400 font-medium` (e.g., "@everyone" or "@here")
- Dimmed description: "Notify all online users" / "Notify everyone in channel"

**`:group` type:**
- Group icon (use a people/group SVG icon in a colored circle, use `item.group.color` if set, else green)
- Group name in green-400 (e.g., "@moderators")
- Dimmed member count or group name in `text-gray-400 text-xs`

Import this component in `channel_live.ex` with `import CromulentWeb.Components.MentionAutocomplete`.

ARIA accessibility: Follow WAI-ARIA combobox pattern:
- Listbox has `role="listbox"` and `aria-label`
- Each option has `role="option"`, unique `id`, and `aria-selected`
- The input (in channel_live template) should get `role="combobox"`, `aria-autocomplete="list"`, `aria-controls="mention-listbox"`, `aria-expanded={@autocomplete_open}`
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile --warnings-as-errors 2>&1 | tail -20</automated>
  </verify>
  <done>
- MentionAutocomplete component renders a dropdown above the input
- Users show avatar initial + display name + dimmed @username
- Broadcast targets (@everyone, @here) show with indigo styling
- Groups show with green styling and group icon
- Max 5 items visible before scroll
- ARIA attributes present for accessibility
- Selected item has highlighted background
  </done>
</task>

</tasks>

<verification>
1. `mix compile --warnings-as-errors` passes with no errors
2. The autocomplete component renders when `autocomplete_open` is true
3. All three item types (user, broadcast, group) have distinct visual styling
4. ARIA attributes are correctly set on listbox and options
</verification>

<success_criteria>
- ChannelLive manages autocomplete state with open/close/navigate/select events
- filter_mention_targets returns correctly filtered and ranked results for all three types
- Dropdown component renders above input with Flowbite dark theme styling
- Code compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-mention-autocomplete/01-01-SUMMARY.md`
</output>
