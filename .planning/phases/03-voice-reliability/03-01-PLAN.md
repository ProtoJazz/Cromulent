---
phase: 03-voice-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cromulent/turn/provider.ex
  - lib/cromulent/turn/coturn.ex
  - lib/cromulent/turn/metered.ex
  - config/runtime.exs
autonomous: true
requirements:
  - VOIC-02
must_haves:
  truths:
    - "TURN provider behaviour module exists with get_ice_servers/1 callback"
    - "Coturn implementation generates HMAC-SHA1 time-limited credentials using OTP :crypto"
    - "Metered implementation fetches credentials via Finch HTTP call"
    - "STUN-only fallback is the default when TURN_PROVIDER env var is not set"
    - "TURN env vars (TURN_PROVIDER, TURN_SECRET, TURN_URL, TURN_API_URL) are read in config/runtime.exs"
  artifacts:
    - path: "lib/cromulent/turn/provider.ex"
      provides: "Behaviour definition with @callback get_ice_servers/1"
      contains: "@callback get_ice_servers"
    - path: "lib/cromulent/turn/coturn.ex"
      provides: "HMAC-SHA1 Coturn credentials"
      exports: ["get_ice_servers/1"]
    - path: "lib/cromulent/turn/metered.ex"
      provides: "Metered.ca REST API credential fetch"
      exports: ["get_ice_servers/1"]
    - path: "config/runtime.exs"
      provides: "TURN env var reads"
      contains: "TURN_PROVIDER"
  key_links:
    - from: "lib/cromulent/turn/coturn.ex"
      to: ":crypto.mac/4"
      via: "OTP built-in :crypto module"
      pattern: ":crypto.mac\\(:hmac"
    - from: "lib/cromulent/turn/metered.ex"
      to: "Cromulent.Finch"
      via: "Finch.request/2 (already in supervisor)"
      pattern: "Finch.request.*Cromulent.Finch"
---

<objective>
Create the Elixir TURN provider abstraction: a @behaviour module with two concrete implementations (Coturn and Metered.ca) and a STUN-only default. This is the server-side credential generation layer that Plan 03 will call when handling join_voice events.

Purpose: Users behind restrictive NATs need TURN relay to establish voice connections. Credentials must be generated server-side using HMAC-SHA1 (the secret must never reach the browser). The behaviour pattern makes the provider swappable via environment variable with zero code changes.

Output: Three new Elixir modules in `lib/cromulent/turn/` and updated `config/runtime.exs` with TURN env var reads.
</objective>

<execution_context>
@/home/protojazz/.claude/get-shit-done/workflows/execute-plan.md
@/home/protojazz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-reliability/03-RESEARCH.md

<interfaces>
<!-- Key OTP / library interfaces the executor needs. No codebase exploration required. -->

Erlang :crypto (OTP 26+ — use :crypto.mac/4, NOT the deprecated :crypto.hmac/3):
```elixir
# Correct form for OTP 24+
:crypto.mac(:hmac, :sha, key_binary, data_binary) :: binary()
# Then Base64-encode the output
Base.encode64(binary) :: String.t()
```

Finch (already started as Cromulent.Finch in application supervisor):
```elixir
Finch.build(:get, url) |> Finch.request(Cromulent.Finch)
# Returns {:ok, %Finch.Response{status: integer(), body: binary()}} | {:error, term()}
```

Jason (already in mix.exs):
```elixir
Jason.decode!(binary) :: map() | list()
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TURN provider behaviour and Coturn implementation</name>
  <files>lib/cromulent/turn/provider.ex, lib/cromulent/turn/coturn.ex</files>
  <action>
Create `lib/cromulent/turn/` directory and two files:

**`lib/cromulent/turn/provider.ex`** — defines the behaviour:
```elixir
defmodule Cromulent.Turn.Provider do
  @moduledoc """
  Behaviour for TURN server credential providers.
  Implementations return an iceServers array for RTCPeerConnection.
  """

  @callback get_ice_servers(user_id :: integer()) ::
              {:ok, list(map())} | {:error, term()}
end
```

**`lib/cromulent/turn/coturn.ex`** — HMAC-SHA1 time-limited credentials (RFC 8489 / Coturn `use-auth-secret` scheme):
```elixir
defmodule Cromulent.Turn.Coturn do
  @moduledoc """
  TURN credentials for self-hosted Coturn server.
  Uses HMAC-SHA1 time-limited credential scheme (RFC 8489).
  Requires env vars: TURN_SECRET, TURN_URL
  """
  @behaviour Cromulent.Turn.Provider

  @impl true
  def get_ice_servers(user_id) do
    secret = System.get_env("TURN_SECRET") || raise "TURN_SECRET env var not set"
    turn_url = System.get_env("TURN_URL") || raise "TURN_URL env var not set"

    ttl = System.system_time(:second) + 3600
    username = "#{ttl}:#{user_id}"
    # Use :crypto.mac/4 — :crypto.hmac/3 was removed in OTP 26
    password = :crypto.mac(:hmac, :sha, secret, username) |> Base.encode64()

    {:ok,
     [
       %{urls: "stun:stun.l.google.com:19302"},
       %{urls: turn_url, username: username, credential: password}
     ]}
  end
end
```

Note on TURN_URL format: it should be the full TURN URI, e.g. `"turn:your-server.example.com:3478"`. The value comes from the TURN_URL env var set in runtime.exs.
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile 2>&1 | grep -E "error|warning" | grep -v "recompiling" || echo "Compile clean"</automated>
  </verify>
  <done>Both files compile without errors. Provider behaviour defines @callback get_ice_servers/1. Coturn uses :crypto.mac(:hmac, :sha, ...) not the deprecated :crypto.hmac/3.</done>
</task>

<task type="auto">
  <name>Task 2: Create Metered provider and extend runtime.exs with TURN env vars</name>
  <files>lib/cromulent/turn/metered.ex, config/runtime.exs</files>
  <action>
**`lib/cromulent/turn/metered.ex`** — Metered.ca REST API credential fetch:

The Metered API URL follows the pattern `https://<appname>.metered.live/api/v2/turn/credentials?secretKey=<key>`. Rather than hardcoding the subdomain format, read the full base URL from TURN_API_URL (e.g., `https://yourapp.metered.live`) and append the path. This is more flexible.

```elixir
defmodule Cromulent.Turn.Metered do
  @moduledoc """
  TURN credentials via Metered.ca managed service REST API.
  Requires env vars: TURN_API_KEY, TURN_API_URL (e.g. https://yourapp.metered.live)
  """
  @behaviour Cromulent.Turn.Provider

  @impl true
  def get_ice_servers(_user_id) do
    api_key = System.get_env("TURN_API_KEY") || raise "TURN_API_KEY env var not set"
    base_url = System.get_env("TURN_API_URL") || raise "TURN_API_URL env var not set"
    url = "#{base_url}/api/v2/turn/credentials?secretKey=#{api_key}"

    case Finch.build(:get, url) |> Finch.request(Cromulent.Finch) do
      {:ok, %Finch.Response{status: 200, body: body}} ->
        # Metered returns a list of credential objects
        # Normalize each entry to RTCPeerConnection iceServers format
        servers =
          body
          |> Jason.decode!()
          |> Enum.map(fn cred ->
            %{
              urls: cred["urls"],
              username: cred["username"],
              credential: cred["credential"]
            }
          end)

        {:ok, servers}

      {:ok, %Finch.Response{status: status}} ->
        {:error, {:http_error, status}}

      {:error, reason} ->
        {:error, reason}
    end
  end
end
```

**`config/runtime.exs`** — Add TURN env var documentation block. These vars are optional (no raise if missing at boot — they're only raised inside the provider implementations when actually called). Add a comment block after the existing prod config block, at the top level (outside the `if config_env() == :prod do` block so it applies to all environments):

Append this section to the end of `config/runtime.exs` (before the final `end` of the prod block, but actually as a top-level comment block after the prod `end`):

```elixir
# TURN server configuration (optional — defaults to STUN-only if not set)
# TURN_PROVIDER: "coturn" | "metered" | unset (STUN-only)
# For coturn: set TURN_SECRET and TURN_URL (e.g. "turn:your-server.example.com:3478")
# For metered: set TURN_API_KEY and TURN_API_URL (e.g. "https://yourapp.metered.live")
# See: lib/cromulent/turn/coturn.ex and lib/cromulent/turn/metered.ex
```

The env vars themselves (TURN_SECRET, TURN_URL, TURN_API_KEY, TURN_API_URL, TURN_PROVIDER) do NOT need `config` stanzas — they are read at runtime via `System.get_env/1` directly in the provider modules. Just add the documentation comment block so operators know what to set.
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile 2>&1 | grep -E "error|warning" | grep -v "recompiling" | grep -v "recompiled" || echo "Compile clean"</automated>
  </verify>
  <done>Metered module compiles cleanly with @behaviour Cromulent.Turn.Provider. runtime.exs has a comment block documenting the TURN env vars. No compilation errors.</done>
</task>

</tasks>

<verification>
After both tasks:
- `mix compile` exits 0 with no errors
- `lib/cromulent/turn/provider.ex` exists and defines `Cromulent.Turn.Provider` behaviour
- `lib/cromulent/turn/coturn.ex` implements the behaviour, uses `:crypto.mac(:hmac, :sha, ...)`
- `lib/cromulent/turn/metered.ex` implements the behaviour, uses `Finch.request/2`
- `config/runtime.exs` has TURN env var documentation
</verification>

<success_criteria>
Three provider modules compile. The abstraction is ready for Plan 03 to call via the dispatch function. No new Mix dependencies added.
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-reliability/03-01-SUMMARY.md` with:
- Files created/modified
- Any deviations from the plan
- Key implementation notes for downstream plans (Plan 03 needs to know the dispatch pattern)
</output>
