---
phase: 03-voice-reliability
plan: 04
type: execute
wave: 3
depends_on:
  - "03-03"
files_modified:
  - assets/js/voice.js
  - assets/js/app.js
  - lib/cromulent_web/components/voice_bar.ex
  - lib/cromulent_web/components/sidebar.ex
autonomous: false
requirements:
  - VOIC-01
  - VOIC-02
must_haves:
  truths:
    - "JS VoiceRoom accepts iceServers as a constructor parameter ‚Äî no hardcoded ICE_SERVERS constant"
    - "app.js voice:join handler destructures ice_servers from event and passes to VoiceRoom constructor"
    - "app.js pushes voice_state_changed events (connected/disconnected) back to LiveView"
    - "VoiceBar shows yellow dot + 'Connecting...' while connecting, green dot + channel name when connected, red dot + 'Disconnected' when disconnected"
    - "User can visually confirm connection state in the VoiceBar"
  artifacts:
    - path: "assets/js/voice.js"
      provides: "VoiceRoom class accepting iceServers param; removes hardcoded ICE_SERVERS constant"
      contains: "constructor(channelId, userId, socket, iceServers)"
    - path: "assets/js/app.js"
      provides: "voice:join handler consuming ice_servers; pushEvent voice_state_changed"
      contains: "voice_state_changed"
    - path: "lib/cromulent_web/components/voice_bar.ex"
      provides: "Dynamic connection state dot and label"
      contains: "connection_state"
    - path: "lib/cromulent_web/components/sidebar.ex"
      provides: "Passes voice_connection_state attr to VoiceBar"
      contains: "voice_connection_state"
  key_links:
    - from: "assets/js/app.js voice:join"
      to: "VoiceRoom constructor"
      via: "new VoiceRoom(channel_id, user_id, voiceSocket, ice_servers)"
      pattern: "new VoiceRoom.*ice_servers"
    - from: "assets/js/app.js"
      to: "channel_live.ex handle_event voice_state_changed"
      via: "this.pushEvent('voice_state_changed', { state: 'connected' })"
      pattern: "voice_state_changed"
    - from: "lib/cromulent_web/components/sidebar.ex"
      to: "lib/cromulent_web/components/voice_bar.ex"
      via: "voice_connection_state attr passed through from socket assigns"
      pattern: "voice_connection_state"
---

<objective>
Wire the client-side half of the voice reliability changes: update JS to consume dynamic ICE servers and report connection state back to LiveView, then update VoiceBar to display the three connection states with color-coded dots and labels.

Purpose: The server now sends ice_servers in the join event (Plan 03). The JS must consume them instead of the hardcoded constant. VoiceBar needs to reflect the current state so users can see whether they're connecting, connected, or disconnected.

Output: Updated voice.js (iceServers param), app.js (consume ice_servers, push state events), voice_bar.ex (dynamic state UI), sidebar.ex (pass connection_state attr).
</objective>

<execution_context>
@/home/protojazz/.claude/get-shit-done/workflows/execute-plan.md
@/home/protojazz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-reliability/03-RESEARCH.md
@.planning/phases/03-voice-reliability/03-03-SUMMARY.md

<interfaces>
<!-- Key interfaces extracted from existing codebase. Executor should use these directly. -->

Current VoiceRoom constructor signature (assets/js/voice.js line 13-23):
```javascript
class VoiceRoom {
  constructor(channelId, userId, socket) {
    this.channelId = channelId
    this.userId = String(userId)
    this.peers = {}
    this.channel = null
    this.localStream = null
    this.channel = socket.channel(`voice:${channelId}`)
    this.bindChannelEvents()
  }
```

Current createPeer uses hardcoded ICE_SERVERS constant (line 162-166):
```javascript
createPeer(remoteUserId, isOfferer) {
  // ...
  const peer = new RTCPeerConnection(ICE_SERVERS)  // <-- hardcoded
```

Current app.js VoiceRoom hook mounted() handler (line 40-62):
```javascript
this.handleEvent("voice:join", ({ channel_id, user_token, user_id }) => {
  // ...
  voiceRoom = new VoiceRoom(channel_id, user_id, voiceSocket)
  voiceRoom.join()
})
```

From Plan 03: server now sends ice_servers in push_event payload:
```elixir
push_event("voice:join", %{
  channel_id: channel_id,
  user_token: socket.assigns.user_token,
  user_id: socket.assigns.user_id,
  ice_servers: ice_servers   # <-- new field
})
```

From Plan 03: voice_state_changed server event handler accepts:
```javascript
// JS pushes this to update VoiceBar state:
this.pushEvent("voice_state_changed", { state: "connected" })  // or "disconnected"
```

Current sidebar.ex voice_bar call (line 216-217):
```elixir
<%= if @voice_channel do %>
  <.voice_bar voice_channel={@voice_channel} />
```

Current VoiceBar attr:
```elixir
attr :voice_channel, :any, required: true
```

Socket assign from Plan 03: `voice_connection_state` is `:connecting | :connected | :disconnected | nil`
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update voice.js and app.js for dynamic ICE servers and connection state</name>
  <files>assets/js/voice.js, assets/js/app.js</files>
  <action>
**voice.js changes:**

1. **Remove the top-level `ICE_SERVERS` constant** (lines 1-11 ‚Äî the entire `const ICE_SERVERS = { iceServers: [...] }` block). This constant is replaced by the instance variable.

2. **Update `VoiceRoom` constructor** to accept `iceServers` as a 4th parameter with a safe default:
```javascript
constructor(channelId, userId, socket, iceServers) {
  this.channelId = channelId
  this.userId = String(userId)
  this.peers = {}
  this.channel = null
  this.localStream = null
  // Use dynamic ICE servers from server; fall back to STUN-only if not provided
  this.iceServers = iceServers || [{ urls: "stun:stun.l.google.com:19302" }]
  this.channel = socket.channel(`voice:${channelId}`)
  this.bindChannelEvents()
}
```

3. **Update `createPeer`** to use `this.iceServers` instead of the removed `ICE_SERVERS` constant:
```javascript
// Replace: const peer = new RTCPeerConnection(ICE_SERVERS)
const peer = new RTCPeerConnection({ iceServers: this.iceServers })
```

**app.js changes:**

1. **Update the `voice:join` handleEvent** to destructure `ice_servers` and pass it to the VoiceRoom constructor, and to push `voice_state_changed` events back to the LiveView:

Replace the existing handler:
```javascript
this.handleEvent("voice:join", ({ channel_id, user_token, user_id, ice_servers }) => {
  // Leave existing voice session if switching channels
  if (voiceRoom) {
    voiceRoom.leave()
    voiceRoom = null
  }
  if (voiceSocket) {
    voiceSocket.disconnect()
    voiceSocket = null
  }

  console.log("Joining voice channel:", channel_id)

  voiceSocket = new Socket("/socket", { params: { token: user_token } })
  voiceSocket.connect()

  voiceSocket.onOpen(() => console.log("Voice socket connected"))
  voiceSocket.onError((err) => console.error("Voice socket error:", err))
  voiceSocket.onClose(() => console.log("Voice socket closed"))

  voiceRoom = new VoiceRoom(channel_id, user_id, voiceSocket, ice_servers)
  voiceRoom.join()
    .then(() => {
      // Phoenix Channel join succeeded = "connected" (peers connect independently)
      this.pushEvent("voice_state_changed", { state: "connected" })
    })
    .catch((err) => {
      console.error("Failed to join voice channel:", err)
      this.pushEvent("voice_state_changed", { state: "disconnected" })
    })
})
```

Note: `voiceRoom.join()` already returns a Promise (it uses `async join()` in voice.js). The `.then()/.catch()` pattern works with the existing implementation ‚Äî `join()` awaits `getUserMedia` and calls `this.channel.join()`. However, `this.channel.join()` is a Phoenix Channel push that uses `.receive("ok")/.receive("error")` callbacks, not a Promise. Wrap the channel join in a Promise inside `join()`:

Update `join()` in voice.js to return a Promise that resolves on channel "ok" and rejects on "error":
```javascript
async join() {
  this.localStream = await navigator.mediaDevices.getUserMedia({
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      sampleRate: 48000
    }
  })
  console.log("üé§ Got local stream", this.localStream.getTracks())

  return new Promise((resolve, reject) => {
    this.channel.join()
      .receive("ok", () => {
        console.log("‚úÖ Joined voice channel")
        this.enablePTT(' ')  // spacebar
        resolve()
      })
      .receive("error", (err) => {
        console.error("‚ùå Failed to join:", err)
        reject(err)
      })
  })
}
```

Also add `peer.onconnectionstatechange` state reporting in `createPeer` to detect disconnection after initial join (peer drops mid-call):
In the existing `peer.onconnectionstatechange` callback, add LiveView notification via a stored hook reference. This requires storing `this` context. The simplest approach: if `peer.connectionState === "failed"` or `"disconnected"`, and we have a reference to the LV hook, push the event. However, `createPeer` doesn't have direct access to the LiveView hook's `pushEvent`.

Instead of storing a hook reference in VoiceRoom (adds coupling), use a custom DOM event that app.js listens for. But this adds complexity. Per the research notes and user decisions, the primary requirement is reporting connect/disconnect on channel join ‚Äî `peer.onconnectionstatechange` for mid-call drops is a secondary concern. Keep it simple: the `.then()/.catch()` on `join()` covers the main case. Document in a comment that mid-call peer drop detection can be added in a future phase if needed.

Leave the existing `peer.onconnectionstatechange` handler as-is (it already logs the state).
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && node --input-type=module --eval "import './assets/js/voice.js'" 2>&1 | head -5 || echo "Check: ICE_SERVERS constant removed" && grep -n "ICE_SERVERS" /home/protojazz/workspace/cromulent/assets/js/voice.js | head -5 || echo "ICE_SERVERS constant removed"</automated>
  </verify>
  <done>voice.js has no top-level ICE_SERVERS constant. VoiceRoom constructor accepts iceServers param. createPeer uses this.iceServers. join() returns a Promise. app.js voice:join handler destructures ice_servers and calls pushEvent("voice_state_changed").</done>
</task>

<task type="auto">
  <name>Task 2: Update VoiceBar component and Sidebar to pass connection state</name>
  <files>lib/cromulent_web/components/voice_bar.ex, lib/cromulent_web/components/sidebar.ex</files>
  <action>
**voice_bar.ex changes:**

Replace the entire module with the dynamic state version. The component gains a `connection_state` attr with default `:connecting` (so existing callers without the attr don't crash). The dot and label are now conditional on connection_state.

Three states per user decisions:
- `:connecting` ‚Üí yellow dot (`bg-yellow-500`) + yellow text + "Connecting..."
- `:connected` ‚Üí green dot (`bg-green-500`) + green text + channel name
- `:disconnected` ‚Üí red dot (`bg-red-500`) + red text + "Disconnected"

```elixir
defmodule CromulentWeb.Components.VoiceBar do
  use Phoenix.Component

  attr :voice_channel, :any, required: true
  attr :connection_state, :atom, default: :connecting

  def voice_bar(assigns) do
    ~H"""
    <div class="px-3 py-3 border-t border-gray-700 bg-gray-900">
      <div class="flex items-center justify-between mb-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class={[
            "w-2 h-2 rounded-full flex-shrink-0",
            @connection_state == :connecting && "bg-yellow-500",
            @connection_state == :connected && "bg-green-500",
            @connection_state == :disconnected && "bg-red-500"
          ]}></div>
          <span class={[
            "text-sm font-medium truncate",
            @connection_state == :connecting && "text-yellow-500",
            @connection_state == :connected && "text-green-500",
            @connection_state == :disconnected && "text-red-500"
          ]}>
            <%= case @connection_state do %>
              <% :connecting -> %>Connecting...
              <% :connected -> %>{@voice_channel.name}
              <% :disconnected -> %>Disconnected
              <% _ -> %>Connecting...
            <% end %>
          </span>
        </div>
        <button
          phx-click="leave_voice"
          class="p-1.5 text-gray-400 hover:text-red-400 rounded hover:bg-gray-700"
          title="Disconnect"
        >
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2M5 3a2 2 0 00-2 2v1c0 8.284 6.716 15 15 15h1a2 2 0 002-2v-3.28a1 1 0 00-.684-.948l-4.493-1.498a1 1 0 00-1.21.502l-1.13 2.257a11.042 11.042 0 01-5.516-5.517l2.257-1.128a1 1 0 00.502-1.21L9.228 3.683A1 1 0 008.279 3H5z" />
          </svg>
        </button>
      </div>
      <button
        id="ptt-button"
        class="w-full select-none touch-none px-4 py-2 rounded bg-gray-700 text-gray-300 text-sm font-medium active:bg-green-600 active:text-white"
        data-active="false"
      >
        Push to Talk
      </button>
    </div>
    """
  end
end
```

**sidebar.ex changes:**

1. Add `voice_connection_state` attr to the sidebar component (after the existing `voice_channel` attr):
```elixir
attr :voice_connection_state, :atom, default: nil
```

2. Update the VoiceBar call to pass the new attr:
```elixir
<%= if @voice_channel do %>
  <.voice_bar voice_channel={@voice_channel} connection_state={@voice_connection_state || :connecting} />
<% end %>
```

3. The `app.html.heex` sidebar call passes `voice_channel={assigns[:voice_channel]}` ‚Äî add `voice_connection_state={assigns[:voice_connection_state]}` to the `<.sidebar>` call in `lib/cromulent_web/components/layouts/app.html.heex`. Find the sidebar call:
```heex
<.sidebar
  channels={assigns[:channels] || []}
  current_user={@current_user}
  voice_presences={assigns[:voice_presences] || %{}}
  voice_channel={assigns[:voice_channel]}
  current_channel={assigns[:channel]}
  join_modal_type={assigns[:join_modal_type]}
  unread_counts={assigns[:unread_counts] || %{}}
  mention_counts={assigns[:mention_counts] || %{}}
/>
```
Add the new attr:
```heex
voice_connection_state={assigns[:voice_connection_state]}
```

Note: `app.html.heex` is a layout template, not a LiveView ‚Äî so use `assigns[:voice_connection_state]` (safe access, returns nil if not set) to handle cases where the layout renders for non-voice pages. The sidebar attr has `default: nil` and the voice_bar call uses `|| :connecting` as a safe fallback.
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile 2>&1 | grep -E "error" | grep -v "recompiling" | grep -v "recompiled" || echo "Compile clean"</automated>
  </verify>
  <done>voice_bar.ex compiles with connection_state attr and three conditional dot colors. sidebar.ex passes voice_connection_state to voice_bar. app.html.heex passes voice_connection_state from assigns to sidebar. No compilation errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Full Phase 3 implementation:
1. TURN provider Elixir modules (Plans 01-02)
2. Coturn in docker-compose
3. Double-join prevention via Phoenix Presence guard
4. TURN credentials injected into voice:join event
5. VoiceBar shows connecting/connected/disconnected states
  </what-built>
  <how-to-verify>
**Start the app:** `mix phx.server`

**Test 1: Connection state display**
1. Open http://localhost:4000 in a browser tab, log in
2. Click a voice channel in the sidebar
3. VoiceBar should appear with yellow dot + "Connecting..." briefly, then green dot + channel name
4. Click the disconnect button ‚Äî VoiceBar should disappear

**Test 2: Double-join prevention**
1. Open two browser tabs both logged in as the same user
2. In tab 1: click a voice channel
3. In tab 2: click the same voice channel
4. Open browser devtools console in tab 2 ‚Äî should see "‚ùå Failed to join: {reason: 'already_in_channel'}" in console (silent failure, no popup)
5. Tab 2 VoiceBar should NOT appear (or should show "Disconnected" state)

**Test 3: Cross-channel auto-leave (if you have 2+ voice channels)**
1. Join voice channel A
2. Click voice channel B (without leaving A first)
3. Verify: VoiceBar updates to show channel B, not A
4. In browser console: should see "Leaving voice channel" followed by "Joining voice channel: [B's id]"

**Test 4: STUN-only mode (default)**
1. Confirm no TURN_PROVIDER env var is set
2. Join a voice channel ‚Äî it should work normally (STUN-only behavior preserved)
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After automated tasks:
- `mix compile` exits 0
- `grep -n "ICE_SERVERS" assets/js/voice.js` returns nothing (constant removed)
- `grep -n "ice_servers" assets/js/app.js` shows destructuring in voice:join handler
- `grep -n "voice_state_changed" assets/js/app.js` shows pushEvent call
- `grep -n "connection_state" lib/cromulent_web/components/voice_bar.ex` shows attr and conditional classes
- `grep -n "voice_connection_state" lib/cromulent_web/components/sidebar.ex` shows attr and pass-through

After human checkpoint:
- All four manual tests pass
</verification>

<success_criteria>
Phase 3 complete: TURN credentials flow from server to JS via push_event payload. VoiceBar shows real connection state. Duplicate joins are rejected silently. Cross-channel switching works cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-reliability/03-04-SUMMARY.md` with:
- Files modified and what changed
- Checkpoint outcome (approved / issues found and resolved)
- Any behavior notes for future phases
</output>
