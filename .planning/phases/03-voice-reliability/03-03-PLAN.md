---
phase: 03-voice-reliability
plan: 03
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - lib/cromulent_web/channels/voice_channel.ex
  - lib/cromulent_web/live/channel_live.ex
autonomous: true
requirements:
  - VOIC-01
  - VOIC-02
must_haves:
  truths:
    - "User cannot join the same voice channel twice — second join returns error with reason 'already_in_channel'"
    - "User switching voice channels automatically leaves the current channel before joining the new one"
    - "TURN credentials are fetched server-side and included in the voice:join push_event payload"
    - "voice_connection_state assign is set to :connecting on join and updated to :connected/:disconnected via voice_state_changed events from JS"
    - "TURN credential generation failure falls back to STUN-only gracefully (no crash)"
  artifacts:
    - path: "lib/cromulent_web/channels/voice_channel.ex"
      provides: "Presence-based duplicate-join guard in join/3"
      contains: "already_in_channel"
    - path: "lib/cromulent_web/live/channel_live.ex"
      provides: "Cross-channel auto-leave, TURN credential fetch, voice_connection_state assign, voice_state_changed handler"
      contains: "voice_connection_state"
  key_links:
    - from: "lib/cromulent_web/channels/voice_channel.ex"
      to: "CromulentWeb.Presence.list/1"
      via: "Presence.list called with topic string before allowing join"
      pattern: "Presence.list"
    - from: "lib/cromulent_web/live/channel_live.ex"
      to: "Cromulent.Turn.Coturn or Metered or STUN-only"
      via: "get_ice_servers/1 private function dispatching on TURN_PROVIDER env"
      pattern: "get_ice_servers"
    - from: "lib/cromulent_web/live/channel_live.ex push_event"
      to: "JS app.js voice:join handler"
      via: "ice_servers key added to push_event payload"
      pattern: "ice_servers"
---

<objective>
Add the two core server-side reliability features: (1) prevent duplicate voice channel joins using Phoenix Presence, (2) inject TURN credentials into the voice:join event. Also add the voice_connection_state lifecycle on the LiveView socket so VoiceBar can display connection status.

Purpose: VOIC-01 prevents the "ghost user" bug where a user appears in a channel multiple times. VOIC-02 server-side wiring ensures the JS hook receives dynamic ICE servers instead of a hardcoded STUN URL.

Output: Modified voice_channel.ex (join guard) and channel_live.ex (cross-channel leave, TURN fetch, connection state assigns/handler).
</objective>

<execution_context>
@/home/protojazz/.claude/get-shit-done/workflows/execute-plan.md
@/home/protojazz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-reliability/03-RESEARCH.md
@.planning/phases/03-voice-reliability/03-01-SUMMARY.md

<interfaces>
<!-- Key interfaces extracted from existing codebase. Executor should use these directly. -->

From lib/cromulent_web/channels/voice_channel.ex (current join/3):
```elixir
def join("voice:" <> channel_id, _params, socket) do
  channel = channel_id |> parse_id() |> Cromulent.Channels.get_channel()

  if channel && channel.type == :voice do
    send(self(), :after_join)
    {:ok, assign(socket, :channel_id, channel_id)}
  else
    {:error, %{reason: "not found"}}
  end
end
```

Phoenix Presence API (already aliased: `alias CromulentWeb.Presence`):
```elixir
# List by topic string — returns map keyed by tracked key
Presence.list("voice:#{channel_id}") :: %{String.t() => %{metas: [map()]}}

# Check if user key exists
Map.has_key?(presences, to_string(user_id)) :: boolean()
```

From lib/cromulent_web/live/channel_live.ex (current join_voice handler, line 151):
```elixir
def handle_event("join_voice", %{"channel-id" => channel_id}, socket) do
  channel = Cromulent.Channels.get_channel(channel_id)
  Cromulent.VoiceState.join(socket.assigns.current_user.id, channel)

  {:noreply,
   socket
   |> assign(:voice_channel, channel)
   |> push_event("voice:join", %{
     channel_id: channel_id,
     user_token: socket.assigns.user_token,
     user_id: socket.assigns.user_id
   })}
end
```

From 03-01-PLAN (TURN provider dispatch pattern):
```elixir
defp get_ice_servers(user_id) do
  case System.get_env("TURN_PROVIDER") do
    "coturn"  -> Cromulent.Turn.Coturn.get_ice_servers(user_id)
    "metered" -> Cromulent.Turn.Metered.get_ice_servers(user_id)
    _         -> {:ok, [%{urls: "stun:stun.l.google.com:19302"}]}
  end
end
```

Socket assigns relevant to this plan:
- `socket.assigns.current_user` — %User{id: integer, email: string}
- `socket.assigns.user_token` — Phoenix.Token string
- `socket.assigns.user_id` — integer
- `socket.assigns[:voice_channel]` — channel struct or nil (may not be set yet on initial mount)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Presence duplicate-join guard to VoiceChannel</name>
  <files>lib/cromulent_web/channels/voice_channel.ex</files>
  <action>
Modify `join/3` in `VoiceChannel` to check Phoenix Presence before allowing the join. If the user is already tracked in that voice channel's presence topic, reject with `{:error, %{reason: "already_in_channel"}}`.

**Critical detail:** Use `Presence.list("voice:#{channel_id}")` with the topic string (not `Presence.list(socket)`) to check the global presence for that topic — this correctly guards against the user being present from any socket/tab, not just the current one.

**The user_id key in Presence** is tracked as a string (see `handle_info(:after_join, ...)` which calls `Presence.track(socket, socket.assigns.current_user.id, ...)` — the second arg is the key, which is an integer). Presence converts integer keys to strings in the returned map, so use `to_string(socket.assigns.current_user.id)` for the lookup.

Replace the existing `join/3` function:

```elixir
def join("voice:" <> channel_id, _params, socket) do
  channel = channel_id |> parse_id() |> Cromulent.Channels.get_channel()

  if channel && channel.type == :voice do
    presences = Presence.list("voice:#{channel_id}")
    user_key = to_string(socket.assigns.current_user.id)

    if Map.has_key?(presences, user_key) do
      # User already in this channel (rapid reconnect / multiple tabs).
      # Rely on Presence timeout to clear the old entry.
      {:error, %{reason: "already_in_channel"}}
    else
      send(self(), :after_join)
      {:ok, assign(socket, :channel_id, channel_id)}
    end
  else
    {:error, %{reason: "not found"}}
  end
end
```

No other changes to voice_channel.ex — the existing `handle_info(:after_join, ...)`, `terminate/2`, and other handlers remain unchanged.
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile 2>&1 | grep -E "error" | grep -v "recompiling" | grep -v "recompiled" || echo "Compile clean"</automated>
  </verify>
  <done>voice_channel.ex compiles. join/3 contains the Presence.list check and returns {:error, %{reason: "already_in_channel"}} when user is already present.</done>
</task>

<task type="auto">
  <name>Task 2: Add cross-channel auto-leave, TURN wiring, and connection state to channel_live.ex</name>
  <files>lib/cromulent_web/live/channel_live.ex</files>
  <action>
Three changes to channel_live.ex:

**Change 1: Update `mount/3`** to add `voice_connection_state: nil` to the initial assigns (nil = not in a voice channel). This prevents the VoiceBar (Plan 04) from crashing if accessed before voice is joined.

In the `assign(socket, ...)` block inside `mount/3`, add:
```elixir
voice_connection_state: nil,
voice_channel: nil,
```
(voice_channel: nil may already be absent from assigns — adding it explicitly prevents template issues)

**Change 2: Replace `handle_event("join_voice", ...)`** with the updated version that: (a) auto-leaves current channel if already in one, (b) fetches TURN credentials, (c) sets voice_connection_state to :connecting.

Replace the existing `join_voice` handler:
```elixir
def handle_event("join_voice", %{"channel-id" => channel_id}, socket) do
  # Cross-channel auto-leave: if already in a voice channel, push leave event first.
  # Both events arrive in the same LiveView batch; JS processes them in order.
  socket =
    if socket.assigns[:voice_channel] do
      push_event(socket, "voice:leave", %{})
    else
      socket
    end

  channel = Cromulent.Channels.get_channel(channel_id)
  Cromulent.VoiceState.join(socket.assigns.current_user.id, channel)

  ice_servers =
    case get_ice_servers(socket.assigns.current_user.id) do
      {:ok, servers} -> servers
      # Graceful fallback: TURN credential failure falls back to STUN-only.
      # Voice still works on most networks; only restrictive NATs are affected.
      {:error, _reason} -> [%{urls: "stun:stun.l.google.com:19302"}]
    end

  {:noreply,
   socket
   |> assign(:voice_channel, channel)
   |> assign(:voice_connection_state, :connecting)
   |> push_event("voice:join", %{
     channel_id: channel_id,
     user_token: socket.assigns.user_token,
     user_id: socket.assigns.user_id,
     ice_servers: ice_servers
   })}
end
```

**Change 3: Add `handle_event("voice_state_changed", ...)`** to update voice_connection_state based on JS push events. Add this new handler after the `leave_voice` handler:

```elixir
def handle_event("voice_state_changed", %{"state" => state}, socket) do
  connection_state =
    case state do
      "connected" -> :connected
      "disconnected" -> :disconnected
      _ -> socket.assigns[:voice_connection_state]
    end

  {:noreply, assign(socket, :voice_connection_state, connection_state)}
end
```

**Change 4: Update `handle_event("leave_voice", ...)`** to also clear voice_connection_state:

Replace the existing leave_voice handler:
```elixir
def handle_event("leave_voice", _params, socket) do
  Cromulent.VoiceState.leave(socket.assigns.current_user.id)

  {:noreply,
   socket
   |> assign(:voice_channel, nil)
   |> assign(:voice_connection_state, nil)
   |> push_event("voice:leave", %{})}
end
```

**Change 5: Add `get_ice_servers/1` private function** at the bottom of the file (before the `defp typing_text` functions):

```elixir
defp get_ice_servers(user_id) do
  case System.get_env("TURN_PROVIDER") do
    "coturn" -> Cromulent.Turn.Coturn.get_ice_servers(user_id)
    "metered" -> Cromulent.Turn.Metered.get_ice_servers(user_id)
    # No TURN_PROVIDER set = STUN-only mode (default, preserves existing behavior)
    _ -> {:ok, [%{urls: "stun:stun.l.google.com:19302"}]}
  end
end
```
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile 2>&1 | grep -E "error" | grep -v "recompiling" | grep -v "recompiled" || echo "Compile clean"</automated>
  </verify>
  <done>channel_live.ex compiles. Contains: voice_connection_state in mount assigns, updated join_voice handler with ice_servers in push_event, voice_state_changed handler, updated leave_voice clearing voice_connection_state, private get_ice_servers/1 function.</done>
</task>

</tasks>

<verification>
After both tasks:
- `mix compile` exits 0 with no errors
- `voice_channel.ex` join/3 contains `Presence.list("voice:#{channel_id}")` and `"already_in_channel"` error
- `channel_live.ex` push_event("voice:join") payload includes `ice_servers:` key
- `channel_live.ex` has `handle_event("voice_state_changed", ...)` handler
- `channel_live.ex` has `voice_connection_state:` in mount assigns
</verification>

<success_criteria>
Server-side double-join prevention and TURN integration are complete. Plan 04 can now update the JS and VoiceBar knowing the server events are in place.
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-reliability/03-03-SUMMARY.md` with:
- Files modified and what changed in each
- Any deviations from the plan
- Notes for Plan 04 (what events JS should handle, what state transitions exist)
</output>
