---
phase: 02-notification-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cromulent/chat/room_server.ex
  - lib/cromulent_web/live/channel_live.ex
  - assets/js/hooks/notification_handler.js
  - assets/js/app.js
  - priv/static/sounds/mention.mp3
autonomous: true
requirements: [NOTF-01, NOTF-02, NOTF-03, NOTF-04, NOTF-05]

must_haves:
  truths:
    - "Electron users receive native OS desktop notification when mentioned in a channel they're not viewing"
    - "Web browser users receive Web Notifications API alert when mentioned in a channel they're not viewing"
    - "Users hear an audible sound when a desktop notification fires"
    - "No notification fires when user is currently viewing the mentioned channel"
    - "Notification shows author name, channel name, and message preview"
    - "Clicking a notification navigates to the mentioned channel"
  artifacts:
    - path: "assets/js/hooks/notification_handler.js"
      provides: "Desktop notification delivery and sound playback"
      min_lines: 60
    - path: "priv/static/sounds/mention.mp3"
      provides: "Notification alert sound file"
  key_links:
    - from: "lib/cromulent/chat/room_server.ex"
      to: "user:#{user_id} PubSub topic"
      via: "PubSub.broadcast for :desktop_notification"
      pattern: "desktop_notification"
    - from: "lib/cromulent_web/live/channel_live.ex"
      to: "assets/js/hooks/notification_handler.js"
      via: "push_event(\"desktop-notification\", data)"
      pattern: "push_event.*desktop-notification"
    - from: "assets/js/hooks/notification_handler.js"
      to: "Notification API"
      via: "new Notification() for both Electron and Web"
      pattern: "new Notification"
---

<objective>
Add server-to-client desktop notification delivery pipeline for @mentions.

Purpose: When a user is mentioned in a channel they're not currently viewing, they receive a native desktop notification (Electron or Web) with an audible alert sound. This is the core notification delivery mechanism that all other notification features build upon.

Output: Server broadcasts mention data to user-specific PubSub topics, LiveView pushes events to client, JavaScript hook shows desktop notifications with Electron/Web branching, notification sound plays on each alert.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-notification-system/02-CONTEXT.md
@.planning/phases/02-notification-system/02-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From lib/cromulent/chat/room_server.ex:
```elixir
# Existing broadcast_message/3 already receives notified_user_ids
def broadcast_message(channel_id, message, notified_user_ids \\ [])

# Existing handle_cast already broadcasts :unread_changed and :mention_changed per user
# We need to ADD :desktop_notification broadcast in the same loop
```

From lib/cromulent_web/live/channel_live.ex:
```elixir
# mount/3 assigns — current state:
assign(socket,
  user_token: token,
  user_id: socket.assigns.current_user.id,
  channel: nil,
  messages: [],
  # ... other assigns
  mention_counts: %{}
)

# handle_info already handles:
# {:unread_changed} -> refresh_unread_counts(socket)
# {:mention_changed} -> refresh_unread_counts(socket)
# BUT: no user:#{user_id} PubSub subscription exists yet!
# Currently only subscribes to "text:#{channel.id}" in handle_params

# handle_info({:new_message, message}, socket) marks channel as read
# This means if user is VIEWING the channel, message arrives via text:channel PubSub
# and is marked read. Desktop notification should NOT fire in this case.
```

From assets/js/app.js:
```javascript
import MentionAutocomplete from "./hooks/mention_autocomplete"
const Hooks = {
  MentionAutocomplete,
  VoiceRoom: { ... },
  ChatScroll: { ... }
}
// New hook must be added to Hooks object
```

From assets/js/electron-bridge.js:
```javascript
// Electron detection pattern: window.electronAPI exists when running in Electron
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side notification broadcasting and LiveView delivery</name>
  <files>
    lib/cromulent/chat/room_server.ex
    lib/cromulent_web/live/channel_live.ex
  </files>
  <action>
**room_server.ex — Add desktop notification broadcast:**

In the existing `handle_cast({:broadcast_message, message, notified_user_ids}, state)`, AFTER the existing `:mention_changed` broadcast loop, add a NEW loop that broadcasts `:desktop_notification` to each notified user:

```elixir
# After the existing mention_changed loop, add:
channel = Cromulent.Channels.get_channel(state.channel_id)

for user_id <- notified_user_ids do
  notification_data = %{
    channel_id: state.channel_id,
    channel_name: channel.name,
    channel_slug: channel.slug,
    author: message.user.username,
    message_preview: String.slice(message.body, 0..100),
    notification_id: message.id
  }

  PubSub.broadcast(Cromulent.PubSub, "user:#{user_id}", {:desktop_notification, notification_data})
end
```

Include `channel_slug` so the client can navigate via `push_patch` to `/channels/#{slug}`.

**channel_live.ex — Subscribe to user-specific PubSub topic and handle desktop notifications:**

1. In `mount/3`, subscribe to the user-specific topic:
```elixir
Phoenix.PubSub.subscribe(Cromulent.PubSub, "user:#{socket.assigns.current_user.id}")
```

2. Add a new `handle_info` clause for `:desktop_notification` BEFORE the catch-all:
```elixir
def handle_info({:desktop_notification, data}, socket) do
  # Only push desktop notification if user is NOT viewing the mentioned channel
  if socket.assigns.channel == nil or socket.assigns.channel.id != data.channel_id do
    {:noreply, push_event(socket, "desktop-notification", data)}
  else
    {:noreply, socket}
  end
end
```

This implements NOTF-04 (suppress notification when viewing the channel). The check uses the current `socket.assigns.channel` which is set in `handle_params` whenever the user navigates to a channel.

3. Add a `handle_event` for notification click navigation:
```elixir
def handle_event("navigate-to-channel", %{"channel_slug" => slug}, socket) do
  {:noreply, push_patch(socket, to: ~p"/channels/#{slug}")}
end
```
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && mix compile --no-optional-deps 2>&1 | tail -5</automated>
  </verify>
  <done>
    - RoomServer broadcasts :desktop_notification with channel_name, channel_slug, author, message_preview, notification_id to each notified user
    - ChannelLive subscribes to user:#{user_id} PubSub topic on mount
    - ChannelLive pushes "desktop-notification" event to client only when user is NOT viewing the mentioned channel
    - ChannelLive handles "navigate-to-channel" event to push_patch to the channel
  </done>
</task>

<task type="auto">
  <name>Task 2: JavaScript notification handler hook with Electron/Web detection and sound</name>
  <files>
    assets/js/hooks/notification_handler.js
    assets/js/app.js
    priv/static/sounds/mention.mp3
  </files>
  <action>
**Create notification sound file:**

Download a free, short notification sound (MP3 format, under 1 second). Use a simple approach:

```bash
# Generate a simple notification tone using ffmpeg if available, or create a minimal valid MP3
# If ffmpeg is not available, create a placeholder and note it for manual replacement
ffmpeg -f lavfi -i "sine=frequency=880:duration=0.15" -af "afade=t=out:st=0.1:d=0.05" -b:a 64k priv/static/sounds/mention.mp3
```

If ffmpeg is not available, download a free notification sound from a CDN or create a minimal placeholder MP3.

**Create assets/js/hooks/notification_handler.js:**

```javascript
const NotificationHandler = {
  mounted() {
    // Preload notification sound
    this.audio = new Audio('/sounds/mention.mp3');
    this.audio.preload = 'auto';

    this.handleEvent("desktop-notification", (data) => {
      this.showNotification(data);
      this.playSound();
    });
  },

  showNotification(data) {
    const isElectron = typeof window.electronAPI !== 'undefined';
    const title = `${data.author} in #${data.channel_name}`;
    const options = {
      body: data.message_preview,
      icon: '/images/logo.svg',
      tag: `mention-${data.notification_id}`,  // Prevents duplicate notifications
      requireInteraction: false
    };

    if (isElectron) {
      // Electron: Notification API works directly in renderer process
      const notification = new Notification(title, options);
      notification.onclick = () => {
        this.pushEvent("navigate-to-channel", { channel_slug: data.channel_slug });
      };
    } else {
      // Web browser: check/request permission
      if (Notification.permission === "granted") {
        const notification = new Notification(title, options);
        notification.onclick = () => {
          window.focus();
          this.pushEvent("navigate-to-channel", { channel_slug: data.channel_slug });
        };
      } else if (Notification.permission === "default") {
        // Request permission on first notification attempt (not on page load)
        Notification.requestPermission().then(permission => {
          if (permission === "granted") {
            const notification = new Notification(title, options);
            notification.onclick = () => {
              window.focus();
              this.pushEvent("navigate-to-channel", { channel_slug: data.channel_slug });
            };
          }
        });
      }
      // If "denied", silently skip — user chose to block notifications
    }
  },

  playSound() {
    // Clone audio node to allow overlapping sounds if multiple notifications fire rapidly
    const sound = this.audio.cloneNode();
    sound.play().catch(err => {
      // Browsers block autoplay before first user interaction — this is expected
      console.warn('Notification sound blocked (requires user interaction first):', err.message);
    });
  }
};

export default NotificationHandler;
```

Key decisions:
- `tag` field prevents duplicate notifications for the same mention (NOTF-04 dedup)
- Permission request happens on first notification, NOT on page load (per research anti-pattern guidance)
- Sound uses `cloneNode()` for overlapping playback
- Sound failure is logged as warning, not error (expected browser behavior)

**Update assets/js/app.js:**

Add the import and register the hook:

```javascript
import NotificationHandler from "./hooks/notification_handler"
```

Add `NotificationHandler` to the Hooks object alongside MentionAutocomplete, VoiceRoom, and ChatScroll.

**Wire the hook in the DOM:**

The NotificationHandler hook needs a DOM element to attach to. Add it to the `channel_live.ex` render function. Place it as a hidden div near the top of the template, similar to how VoiceRoom hook is placed in `app.html.heex`:

In `channel_live.ex` render, add at the start of the outer div:
```heex
<div id="notification-handler" phx-hook="NotificationHandler" class="hidden"></div>
```

This ensures the hook is mounted when the channel view loads and persists across channel navigation.
  </action>
  <verify>
    <automated>cd /home/protojazz/workspace/cromulent && cd assets && npx esbuild js/app.js --bundle --outdir=/dev/null 2>&1 | tail -5</automated>
  </verify>
  <done>
    - NotificationHandler JS hook created with Electron detection (window.electronAPI check)
    - Electron path: uses native Notification() directly, onclick navigates to channel
    - Web path: checks/requests permission, shows Notification(), onclick focuses window + navigates
    - Sound plays via HTML5 Audio on each notification (with graceful failure for autoplay policy)
    - Hook registered in app.js Hooks object
    - Hook wired to hidden div in channel_live.ex template
    - Notification sound file exists at priv/static/sounds/mention.mp3
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds without new warnings
2. Asset bundle builds without errors
3. Server starts: `mix phx.server` runs without crashes
4. Manual test flow:
   - Open two browser tabs logged in as different users
   - In tab A, send a message mentioning tab B's user (@username)
   - Tab B should receive a desktop notification (if permission granted) and hear a sound
   - Tab B should NOT receive notification if currently viewing the same channel
   - Clicking the notification should navigate to the mentioned channel
</verification>

<success_criteria>
- Desktop notifications appear for Electron users via native Notification API
- Desktop notifications appear for web users via Web Notifications API (with permission flow)
- Notification sound plays on each mention alert
- No notification fires when user is viewing the mentioned channel
- Notification click navigates to the correct channel
- No new compilation errors or asset build failures
</success_criteria>

<output>
After completion, create `.planning/phases/02-notification-system/02-01-SUMMARY.md`
</output>
